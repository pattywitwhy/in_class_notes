# Installed Javascript Packages with Webpack

Quick sublime text note: Sublime text cannot open large files. Because it needs to look at every character and decide whether to perform an operation on it (e.g., make it blue). So if you give it a huge file it'll crash.

Note: the `gem install` command does not need to run in a specific folder, this downloads to your whole computer.

Skull tag shortcuts:
`pe` + `tab` #=> `<%=  %>`
`er` + `tab` #=> `<%  %>`


## Installing the math.js package 

First, we need to install webpack to our list of packages. But, we only want it to run in development mode. When it goes to production, we don't want to use this package because it'll slow down the page loading.

```bash
npm install webpack webpack--cli --save-dev
```

This adds more stuff to our `package.json` file. 

We also need to run

```bash
./node_modules/.bin/webpack index.js
```

This takes all the different Javascript files, and puts them all into one place. It creates a new folder called `dist`, with a `main.js` inside of of it. If you look at `main.js`, it has a bunch of javascript. It has combined together `moment.js` and the `index.js` that we wrote.

In our `index.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Modern JS</title>
  <script src="node_modules/moment/moment.js"></script>
  <script src="node_modules/mathjs/index.js"></script>
  <script src="index.js"></script>
</head>
<body>
  <h1>Hello From HTML</h1>
</body>
</html>
```

And in `index.js`, we need to add the line `var moment = require('moment');`

```js
var moment = require('moment');
var math = require('mathjs');

console.log("Hello, from Javascript");
var datetime = moment().startOf('day').fromNow();
console.log(datetime);

// functions and constants
console.log(math.round(math.e, 3));
console.log(math.atan2(3, -3) / math.pi);
console.log(math.log(10000, 10));
console.log(math.sqrt(-4));
console.log(math.pow([[-1, 2], [3, 1]], 2));
console.log(math.derivative('x^2 + x', 'x'));
```

Now that we've installed webpack, we can trim down our `index.html` file. We don't need to write a require line for each script anymore. We'll get all of it by referencing `main.js` only, not the individual packages, since we incorporated them into `main.js`. Note that webpack is the Javascript equivalent of Bundler in Ruby. Node module and packages are the same thing.

In our `index.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Modern JS</title>
  <script src="dist/main.js"></script>
</head>
<body>
  <h1>Hello From HTML</h1>
</body>
</html>
```

Now we're going to install `math.js`, and then re-build `main.js`:

```bash
npm install mathjs --save
./node_modules/.bin/webpack index.js --mode=development
```

Now, you can load your html page, check the console, and the math will actually work properly. Hooray!

## Now let's make a configuration file

Create a file called `webpack.config.js` in the root directory of your app, and add the following lines:

```js
module.exports = {
  mode: 'development',
  entry: './index.js',
  output: {
    filename: 'main.js',
    publicPath: 'dist'
  }
};
```

Now let's run webpack without the index.js or `--mode-development`, like this:

```bash
./node_modules/.bin/webpack
```

## Using Babble 

It still works, because the config file tells webpack to look at `index.js` and to run in development mode.

ES2015 (formerly ES6) is covered by all browsers. ES2015 updated JS for the first time in many years, but not all computers immediately supported it. For those computers, you need to use a tool like Babble to translate back to prior versions of Javascript. They usually release a new version of ES every year. We're on ES2019 now, but none of the major browsers support it yet. So if you want to write your website using it, you need something like Babble to translate backwards.

```bash
npm install @babel/core @babel/preset-env babel-loader --save-dev
```

In `webpack.config.js` add some stuff:

```js
module.exports = {
  mode: 'development',
  entry: './index.js',
  output: {
    filename: 'main.js',
    publicPath: 'dist'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  }
};
```

Then run webpack:

```bash
./node_modules/.bin/webpack
```

## Making Running Javascript/Webpack Less Annoying

Running webpack is annoying. So let's shorten this, so it automatically runs whenever you make a change.

```bash
./node_modules/.bin/webpack --progress --watch
```

In `package.json`, we're going to add two lines to where it says "scripts":

```json
  "name": "modern_javascript",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack --progress --mode=production",
    "watch": "webpack --progress --watch",
    "server": "webpack-dev-server --open"
  },
```

Now if we want to have this run continually while developing, so we don't have to rebuild every time we make a change, you can use this command:

```bash
npm run watch
```

Hooray! In addition to updating your information every time you change your javascript file, you can also run a server that automatically updates your browser every time you update your javascript file.

To do so, run this line:

```bash
npm install webpack-dev-server --save-dev
npm run server
```

Now, if you make any changes to `index.js` they update automatically! The server is located at `localhost:8080`, and you can follow along jovially with your updates in real time.

## Vie.js - Javascript Front-End Framework

### Common Frameworks

* Backbone.js 
* Angular.js (front end) (by Google)
  * This used to be taught in Actualize
  * It's a nice framework, but then react came out and Angular tried to implement it, but it's bulky and the updates come out so quickly it's kinda brittle. So Actualized moved away from teaching it.
* React.js (Facebook)
  * It's a horrible frontend framework to start with. It's very counterintuitive ("flips your brain inside out"), but once you do get used to it's a really nice.

### Vue.js

A much smaller, lighter framework. This doesn't have the backing of a huge company like Google or Facebook--it's really just one guy developing it. But it's actually doing very well, and Rails considers Vue to be one of the only 3 viable frameworks. 

**Advantages**:

* Speed
  * You don't have to write it all
  * Uses common conventions
* Consistency
  * Others have already tested it out and found bugs
* Easy to find documentation about it

**Disadvantages**:

* It's hard to change
* More specialized, less customizable
* bulky

### Installing Vue.js

```bash
npm install -g @vue/cli
```

(This `-g` in `npm install -g @vue/cli` installs it on the entire computer, not just one directory.)

This failed. But let's change the ownership! Then we can actually run it. We are going to change the ownership to the current user

```bash
sudo chown -R $(whoami) /usr/local/lib/node_modules
```

### Adding Vue.js to the Cookbook App

We're going to build a vue.js app. In ~./actualize

```bash
vue create cookbook_vue_app
cd cookbook_vue_app
npm run serve
```

Now select the features that we want using "manually select features". We want just want Babel and Router. Use history mode. Place config for Babel, PostCSS, etc. in package.json. Then we're going to save this as a preset for future use. We save this as Actualize. Then you can see your first Vue app by opening `http://localhost:8080/`. 

Then install Vue.js devtools chrome extension.

Open the `cookbook_vue_app` in sublime. We're going to be looking at `src/views/home.vue`. We're going to be dealing with this file for the next little while.

Paste the following into `home.vue`.

```html
<template>              <!-- This is where your html (would normally be in body) goes -->
  <div class="home">
    <h1>{{ message }}</h1>    
    <p>{{ message2 }}</p>
    <p>{{ message3 }}</p>
    <p>{{ message4 }}</p>
  </div>
</template>

<style>                 /*This is where your CSS goes*/
</style>

<script>                // This is where your Javascript goes
export default {
  data: function() {
    return {
      message: "OMG We made a Vue App!!",
      message2: "... or did we?",
      message3: "...",
      message4: "... yes we did."
    };
  },
  created: function() {},
  methods: {}
};
</script>
```

Now head back to bash and turn on the server with `npm run serve`.

The `{{ message }}` is similar to ERB syntax. It's the javascript equivalent. You can put runable javascript code into {{}} and it'll run. Hooray! You can see your changes to the message at `http://localhost:8080/`. 



```bash
npm run serve
```

### Mini Capstone Example

```bash
vue create mini_capstone_vue_app
```

Then fork and clone `simple_mini_capstone` into your actualize folder.

```bash
rake db:migrate
rake db:create
rake db:seed
```

Here's what it looks like:

```


```ruby

```

```js

```