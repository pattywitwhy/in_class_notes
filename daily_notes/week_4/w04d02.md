# It's so cold.

## Example with the cookbook app

In our gemfile, add

```ruby 
gem 'jwt'
```

Then

```bash
bundle
rails g controller api/sessions
```

In routes, add this line

```ruby
post '/sessions' => 'sessions#create'
```

Then, in your `sessions_controller.rb` controller, make a create action

```ruby
class Api::SessionsController < ApplicationController
  def create
    user = User.find_by(email: params[:email])
    if user && user.authenticate(params[:password])
      jwt = JWT.encode(
                       {
                        user_id: user.id,
                        exp: 24.hours.from_now.to_i     # Exp is magic from the JWT algorithm. hours.from_now is rails. This token will only be valid for 24 hours, after that it expires and the user needs to login again. 
                       },                               # data
                       Rails.application.credentials.fetch(:secret_key_base),   # salt, a crazy string generated by rails
                       "HS256"                          # algorithm
                       )                   

      render json: { jwt: jwt, email: user.email, user_id: user.id }, status: :created
    else
      render json: { }, status: :unauthorized        # Status code of the web response. 403 maybe?
  end
end
```

The authenticate method checks to make sure the password entered . If the user is not found, find_by returns nil. That's why we need the && logic, so nil won't run the authenticate method (which will error out). If the authentication doesn't come out true, else is triggered and we return the unauthorized status message/code.

If `user && user.authenticate(params[:password])` is true, we want to create a json web token (encrypted string).

`render` is a rails specific device. 

`salt` slightly alters what the encryption is doing. It changes how it mixes each character. In addition to the encrypting algorithm, you also need this salt password to know what it's doing. It's basically a password that tells the algorithm how to encrypt and decrypt data. Note that this is a two-way encryption (one-to-one map), because we need to be able to decrypt the user id to know who is trying to log in.

Head on over to Insomnia, and send up `joe@gmail.com` as the email, and password as the password (you should have added Joe's info yesterday).


### Another thing, again in Cookbook

Go to your `application_controller.rb`. We're going to create a method that allows a user verify who they are, so they can do stuff on their account without logging in again. Since we're doing this on the applicaiton controller, all other controllers will inherit this ability (they all inherit from application controller).


```ruby
protect_from_forgery with: :null_session

def current_user            # We're checking to see someone is signed in.
                            # Returns a user object if true. If not, returns nil, & user must re-login.
  auth_headers = request.headers['Authorization']
    if auth_headers.present? && auth_headers[/(?<=\A(Bearer ))\S+\z/]
      token = auth_headers[/(?<=\A(Bearer ))\S+\z/]

      begin
        decoded_token = JWT.decode(
                                  token,
                                  Rails.application.credentials.fetch(:secret_key_base),
                                  true,
                                  { algorithm: 'HS256'}
                                  )
      User.find_by(id: decoded_token[0]["user_id"])     # Here, the keys will always come back as strings
    rescue JWT::ExpiredSignature
      nil
    end
  end
end

helper_method :current_user   # Makes this available in the main controller and the views. You ONLY use helper_method here. Rails specific, and specific to this file. Must be inside the class, but not in the current_user definition

```

In the main controller (e.g., `products_controller.rb` for mini_capstone), add the following to the index:

```ruby
def index 
  @current_user = current_user

  # other stuff
end

def show
  # @current_user = current_user        # Actually, we don't need this because current_user is sent to the views by the helper method. So you don't actually have to add anything to show.

  #other stuff
end


```

And in the view show.json.jbuilder, add this:

```ruby
if current_user
  json.current_user current_user.email
end
# pre-existing stuff
```

After you've done these steps, you can use /sessions in Insomnia to send in your username/login. It will reply with your jwt string. Copy that string (not including the ""), and under the header tab, send in `Authorization` (exactly), and then `Bearer <jwt token that you just copied>`, making sure there's a space between them. Now you've got the jwt token for that user.

```ruby
```

```bash
```